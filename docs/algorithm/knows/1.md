#  动态规划

今天我们将开始「动态规划」系列的第一个专题「路径问题」，整个专题共十讲。

## 什么是动态规划

1. 如何确定可以使用动态规划来求解问题
2. 对状态转移的要求是什么

## LeetCode练习

1. [斐波那契数列]()
2. [不同路径]

## []()

**描述：**

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

<img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" />

**示例：**

```
输入：m = 3, n = 7
输出：28
```

**代码：**

```js
function dp(m, n) {
    // 创建一个二维数组，初始填充1
    const arr = new Array(m);
    for(let i = 0; i < m; i++){
        arr[i] = new Array(n).fill(1);
    }
    // 将一个大任务拆解成小任务
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            const top = arr[i][j - 1];
            const left = arr[i - 1][j];
            const cur = arr[i - 1][j] + arr[i][j - 1];
            arr[i][j] = cur;
        }
    }
    return arr[m - 1][n - 1]
}
```

**分析：**



动态规划

f(i)

定义 f[i][j] 为到达位置 (i,j) 的不同路径数量。

那么 f[m-1][n-1]f[m−1][n−1] 就是我们最终的答案，而 f[0][0] = 1 是一个显而易见的起始条件。

由于题目限定了我们只能 往下 或者 往右 移动，因此我们按照当前可选方向进行分析：

当前位置只能「往下」移动，即有 f[i][j] = f[i-1][j]

当前位置只能「往右」移动，即有 f[i][j] = f[i][j-1]f[i][j]=f[i][j−1]

当前位置即能「往下」也能「往右」移动，即有 f[i][j] = f[i][j-1] + f[i-1][j]


代码：

Java

class Solution {
    public int uniquePaths(int m, int n) {
        int[][] f = new int[m][n];
        f[0][0] = 1;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i > 0 && j > 0) {
                    f[i][j] = f[i - 1][j] + f[i][j - 1];
                } else if (i > 0) {
                    f[i][j] = f[i - 1][j];
                } else if (j > 0) {
                    f[i][j] = f[i][j - 1];
                }
            }
        }
        return f[m - 1][n - 1];
    }
}
时间复杂度：O(n*m)O(n∗m)
空间复杂度：O(n*m)O(n∗m)
总结
这是一道很简单的动态规划入门题目，相信很多同学都做过。

如果我们真正静下来思考这道题的话，会发现还是有很多有价值的东西可以挖掘的。

1. 我们是如何确定本题可以使用动态规划来解决的？

通常我们要从「有无后效性」进行入手分析。

如果对于某个状态，我们可以只关注状态的值，而不需要关注状态是如何转移过来的话，那么这就是一个无后效性的问题，可以考虑使用 DP 解决。

另外一个更加实在的技巧，我们还可以通过 数据范围 来猜测是不是可以用 DP 来做。

因为 DP 是一个递推的过程，因此如果数据范围是 10^510 
5
 ~10^610 
6
  的话，可以考虑是不是可以使用一维 DP 来解决；如果数据范围是 10^210 
2
 ~10^310 
3
  的话，可以考虑是不是可以使用二维 DP 来做 ...

2. 我们是如何确定本题的状态定义的？

说实话，DP 的状态定义很大程度是靠经验去猜的。

虽然大多数情况都是猜的，但也不是毫无规律，相当一部分题目的状态定义是与「结尾」或「答案」有所关联的。

3. 我们是如何确定状态转移方程的？

通常来说，如果我们的状态定义猜对了，状态转移方程就是对「最后一步的分情况讨论」。

如果我们有一个对的状态定义的话，基本上状态转移方程就是呼之欲出。

因此一定程度上，状态转移方程可以反过来验证我们状态定义猜得是否正确：

如果猜了一个状态定义，然后发现无法列出涵盖所有情况（不漏）的状态转移方程，多半就是状态定义猜错了，赶紧换个思路，而不是去死磕状态转移方程。

4. 对状态转移的要求是什么？

我们的状态转移是要做到「不漏」还是「不重不漏」取决于问题本身：

如果是求最值的话，我们只需要确保「不漏」即可，因为重复不影响结果。
如果是求方案数的话，我们需要确保「不重不漏」。
5. 我们是如何分析动态规划的时间复杂度的？

对于动态规划的复杂度/计算量分析，有多少个状态，复杂度/计算量就是多少。

因此一维 DP 的复杂度通常是线性的 O(n)O(n)，而二维 DP 的复杂度通常是平方的 O(n^2)O(n 
2
 )。

建议
这些关于动态规划的小技巧，我希望你在第一课就学到。

同时，我十分建议刚读完「总结」的你再回头看一遍题解，看看我们这些分析技巧是否都能套入分析思路。

带着这个感觉，随着我们动态规划专题的进行而不断强化，相信你会在求解「动态规划」问题上突飞猛进。

思考
如果我们不限制只能 往右 和 往下 移动的话，还能使用 DP 来做吗？
