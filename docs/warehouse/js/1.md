# 手撕代码

> 这里记录了高频的函数实现
> 陆续会完善每个方法的输入输出，基本参数

## push <Badge type="tip" text="Js" vertical="middle" /> <Badge type="warning" text="Ts" vertical="middle" />

`push()`方法可向数组的末尾添加一个或多个元素，并返回新的长度。

```js
// by 余光
Array.prototype._push = function() {
  const arr = this;
  const len = arr.length;
  const args = arguments;
  for (let i = 0; i < args.length; i++) {
    arr[len + i] = args[i];
  }
  return arr.length;
};

// by zy
Array.prototype._push = function() {
  const arr = this;
  const len = arr.length;
  for (let i = 0; i < arguments.length; i++) {
    arr[len + i] = arguments[i];
  }
  return arr.length;
};
```

Ts 版本

```ts
// 余光
function _push(arr: Array<any>, ...arg: Array<any>) {
  const len = arr.length;
  for (let i = 0; i < arg.length; i++) {
    arr[len + i] = arg[i];
  }
  return arr.length;
}
```

总结：思路基本一致，都是将参数循环添加到数组的末尾

## pop <Badge type="tip" text="Js" vertical="middle" />

`pop()`删除数组最后一项，并返回被删除的值

```js
// by 余光
Array.prototype._pop = function() {
  const arr = this;
  const res = arr[arr.length - 1];
  arr.length = arr.length - 1;
  return res;
};

// by zy
Array.prototype._pop = function() {
  const arr = this;
  const result = arr[arr.length - 1];
  arr.length = arr.length - 1;
  return result;
};
```

## Every <Badge type="tip" text="Js" vertical="middle" />

对数组每项都运行传入的函数，如果对每项函数都返回 true，则这个方法返回 true

```js
// by 余光
Array.prototype._every = function(callback, target = this) {
  const arr = target;
  const len = arr.length;

  if (typeof callback != "function") {
    throw new Error(); // 这里参考zy的分析，添加参数兼容会比较好
  }
  if (len === 0) return []; // 如果为空数组，返回[]

  for (let i = 0; i < len; i++) {
    if (!callback(arr[i], i, arr)) {
      return false;
    }
  }
  return true;
};

// by zy
Array.prototype._every = function(cb, thisValue = this) {
  if (typeof cb != "function") {
    throw new Error();
  }
  if (thisValue.length == 0) {
    return true;
  }
  for (let i = 0; i < thisValue.length; i++) {
    if (!cb(thisValue[i], i, thisValue)) {
      return false;
    }
  }
  return true;
};
```

## some <Badge type="tip" text="Js" vertical="middle" />

对数组每项都运行传入的函数，如果有一项返回`true`，则这个方法返回`true`

```js
// by 余光
Array.prototype._some = function(callback, target = this) {
  const arr = target;
  const len = arr.length;

  if (len === 0) return []; // 如果为空数组，返回[]

  for (let i = 0; i < len; i++) {
    if (callback(arr[i], i, arr)) {
      return true;
    }
  }
  return false;
};

// by zy
Array.prototype._some = function(cb, thisValue = this) {
  if (typeof cb != "function") {
    throw new Error();
  }
  if (thisValue.length == 0) {
    return false;
  }
  for (let i = 0; i < thisValue.length; i++) {
    if (cb(thisValue[i], i, thisValue)) {
      return true;
    }
  }
  return false;
};
```

## filter <Badge type="tip" text="Js" vertical="middle" />

对数组每项都运行传入的函数，函数返回 true 的项组成数组之后返回。

```js
// by 余光
Array.prototype._filter_ = function(callback, target = this) {
  const arr = target; // 保存this
  const result = []; // 返回新数组
  const len = arr.length;

  if (len === 0) return []; // 如果为空数组，返回[]

  for (let i = 0; i < len; i++) {
    if (callback(arr[i], i, arr)) result.push(arr[i]); //如果判定条件为true，保存至新数组
  }
  return result; // 返回符合条件的结果
};

// by zy
Array.prototype._filter = function(cb, thisValue = this) {
  const result = [];
  if (typeof cb != "function") {
    throw new Error();
  }
  if (thisValue.length == 0) {
    return [];
  }
  for (let i = 0; i < thisValue.length; i++) {
    if (cb(thisValue[i], i, thisValue)) {
      result.push(thisValue[i]);
    }
  }
  return result;
};
```

## forEach <Badge type="tip" text="Js" vertical="middle" />

对数组每项都运行传入的函数，无返回值。

```js
// by 余光
Array.prototype._forEach = function(callback, target = this) {
  const arr = target; // 保存this
  const result = []; // 返回新数组
  const len = arr.length;

  if (len === 0) return []; // 如果为空数组，返回[]
  for (let i = 0; i < len; i++) {
    callback(arr[i], i, arr);
  }
  return; // 返回undefined
};

// by zy
Array.prototype._forEach = function(cb, thisValue = this) {
  const result = [];
  if (typeof cb != "function") {
    throw new Error();
  }
  if (thisValue.length == 0) {
    return;
  }
  for (let i = 0; i < thisValue.length; i++) {
    cb(thisValue[i], i, thisValue);
  }
  return;
};
```

## 深浅拷贝 <Badge type="tip" text="Js" vertical="middle" />

```js
// by zy
function shallowCopy(target) {
  if (typeof target === "object" && target != null) {
    const copy = target instanceof Array ? [] : {};
    for (let key in target) {
      if (target.hasOwnProperty(key)) {
        copy[key] = target[key];
      }
    }
    return copy;
  }
  return target;
}

function deepCopy(target) {
  if (typeof target === "object" && target != null) {
    const copy = target instanceof Array ? [] : {};
    for (let key in target) {
      if (target.hasOwnProperty(key)) {
        copy[key] =
          typeof target[key] === "object"
            ? deepClone(target[key])
            : target[key];
      }
    }
    return copy;
  }
  return target;
}

// by 余光
// 浅拷贝，只复制1层
function shallow(target) {
  if (typeof target === "object" && target != null) {
    const copy = target instanceof Array ? [] : {};
    const keys = Object.keys(target);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      copy[key] = target[key];
    }
    return copy;
  }
  // 基本类型，直接返回，在传值的那一刻已经复制了
  return target;
}
// 深拷贝
function deepCopy(target) {
  if (typeof target === "object" && target != null) {
    const copy = target instanceof Array ? [] : {};
    const keys = Object.keys(target);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      copy[key] =
        typeof target[key] === "object" ? deepCopy(target[key]) : target[key];
    }
    return copy;
  }
  // 基本类型，直接返回，在传旨的那一刻已经复制了
  return target;
}
```

## flat <Badge type="tip" text="Js" vertical="middle" />

**描述**

flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。

```js
// by 余光
// 递归方式
Array.prototype._flat = function(deep = 1) {
  // 获取调用者
  let arr = this;
  // 拍平层数校验
  if (deep < 1) return arr;
  //
  return arr.reduce(
    (prev, next, i, n) => [
      ...prev,
      ...(Array.isArray(next) ? next._flat(deep - 1) : [next]),
    ],
    []
  );
};

//zy
Array.prototype.myFlat = function(num = 1) {
  if (num < 0) return this;
  let arr = [];
  this.forEach((item) => {
    if (Array.isArray(item)) {
      arr = arr.concat(item.myFlat(--num));
    } else {
      arr.push(item);
    }
  });
  return arr;
};
```

## bind <Badge type="tip" text="Js" vertical="middle" />

**描述**

> bind() 方法创建一个新的函数，在`bind()`被调用时，这个新函数的`this`被指定为`bind()`的第一个参数，而其余参数将作为新函数的参数，供调用时使用。

```js
// by 余光
Function.prototype._bind = function(context, ...arg) {
  var self = this;
  const fBound = function(...childArg) {
    return self.apply(context, arg.concat(childArg)); // 拼接参数
  };
  fBound.prototype = this.prototype; // 连接原型链
  return fBound;
};
//zy
Function.prototype.myBind = function(context = window, ...args) {
  const fn = this;
  let newFn = function(...secondArgs) {
    fn.call(this, ...args, ...secondArgs);
  };
  newFn.prototype = this.prototype;
  return newFn;
};
```

## call <Badge type="tip" text="Js" vertical="middle" />

使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数

> 第一个参数指定了函数体内 this 对象的指向
> 第二个参数及以后为函数调用的参数

```js
// 余光
Function.prototype._bind = function(obj, ...arg) {
  if (typeof this !== "function") {
    throw new Error("what is trying to be bound is not callable");
  }
  const obj = obj || window; // 可以在参数上设置默认值
  obj.func = this; // 这里推荐使用Symbol

  const result = obj.func(...arg); // 执行函数
  delete obj.func; // 删除函数，当做什么都没发生～
  return result;
};
//zy
Function.prototype.myCall = function(context = window, ...args) {
  const key = Symbol(); // 防止覆盖原有属性
  context[key] = this;
  const result = context[key](...args);
  delete context[key];
  return result;
};
```

- Symbol 可以防止覆盖原有属性 👍

## apply <Badge type="tip" text="Js" vertical="middle" />

> 第一个参数指定了函数体内 this 对象的指向
> 第二个参数为函数调用的参数数组

```js
// 余光
Function.prototype._bind = function(obj = window, arg) {
  const key = Symbol();
  obj[key] = this; // 将函数变成对象的内部属性
  const result = obj[key](...arg); // 执行函数
  delete obj[key]; // 删除函数，当做什么都没发生～
  return result;
};

//zy
Function.prototype.myApply = function(context = window, args) {
  const key = Symbol(); // 防止覆盖原有属性
  context[key] = this;
  const result = context[key](...args);
  delete context[key];
  return result;
};
```

## 判断两个值是否相等

- 如果是基本类型，则直接判断
- 如果是 Date 类型，则比较时间戳
- 判断是否是 null 或者 undefined
- 如果是引用类型则递归比较每一个层级的值是否相等

```js
function equals(a, b) {
  // 基本类型、null、undefined
  if (a === b) return true;
  // Date
  if (a instanceof Date && b instanceof Date) {
    return a.getTime() === b.getTime();
  }
  // 空 或 null
  if (!a || !b || (typeof a !== "object" && typeof b !== "object")) {
    return a === b;
  }
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  // 属性数量不一致
  if (keysA.length !== keysB.length) return false;
  return keysA.every((key) => equals(a[key], b[key]));
}
```

## compose 函数

- 复合函数
- 他是函数式编程中使用较多的一种写法, 通过 compose 的方式组合函数, 将外部数据依次通过各个函数的加工，生成结果。
- 顺序是从右到左

```js
function compose(...arg) {
  // 保存参数列表
  // 按倒叙执行并返回结果作为下一次的参数
  return function(x) {
    return arg.reduceRight((p, f) => f(p), x);
  };
}

const add = (x) => x + x;
const mul = (x) => x * x;
const one = (x) => x + 1;

const newFunc = compose(add, mul, one);
console.log(newFunc(2)); // 18
```

## pipe 函数

- 从左至右，函数操作的结果依次为下一个函数的参数
- pipe(a,b,c) = (...args) => c(b(a(...args)));
- 和 compose 参数传递顺序相反

```js
function Pipe(...funcs) {
  return function(arg) {
    return funcs.reduce((arg, func) => func(arg), arg);
  };
}
```

## 斐波那契数列

- 最经典的问题，指的是这样一个数列：1、1、2、3、5、8、13、21
- 斐波那契数列以如下被以递归的方法定义：F0=0，F1=1，Fn=Fn-1+Fn-2（n>=2，n∈N\*）
- 用文字来说，就是斐波那契数列由 0 和 1 开始，之后的斐波那契数列系数就由之前的两数相加。

```js
// 递归
function fibonacci(n) {
  // 边界
  if (n <= 0) return 0;

  return n <= 2 ? 1 : fibonacci(n - 2) + fibonacci(n - 1);
}

// 动态规划 - 保存结果
function fibonacci(n) {
  // 边界
  if (n <= 0) return 0;
  if (n === 1 || n === 2) return 1;
  // 循环
  const res = [1, 1];
  for (let i = 2; i < n; i++) {
    const cur = res[i - 2] + res[i - 1];
    res.push(cur);
  }
  return res[n - 1];
}

// 动态规划 - 滚动数组
function fibonacci(n) {
  // 边界
  if (n <= 0) return 0;
  if (n === 1 || n === 2) return 1;
  // 循环
  let p = 0,
    q = 0,
    r = 1;
  for (let i = 2; i <= n; i++) {
    p = q;
    q = r;
    r = p + q;
    console.log(">>>:", p, q, r);
  }
  return r;
}
```

可以看看还有没有更优雅的方法？

## 防抖

- 在一个动作发生一定时间内连续触发，只在最后不再触发后执行事件

```js
// by 余光
function debounce(fn, dely) {
  let timer = null;
  return function() {
    // 重复触发，清除定时器
    clearTimeout(timer);
    // 修正this指向
    timer = setTimeout(() => fn.apply(this, arguments), dely);
  };
}
// by zy
function myDebounce(fn,delay){
    let timer = null;
    return function(...args){
        if(timer){
            clearTimeout(timer)
        }
        timer = setTimeout(() => {fn.call(this,...args)},delay);
    }
}
```

## 节流

- 当持续触发函数时，节流函数会帮助你一段时间间隔内执行 1 次函数

```js
// by 余光
// 时间戳版
function throttle(fn, wait) {
  let last = 0;
  return function() {
    let cur = Date.now();
    if (cur - last > wait) {
      fn.apply(this, arguments);
      last = cur;
    }
  };
}

// 定时器版
function throttle(fn, wait) {
  let flag = true;
  return function() {
    if (!flag) return;
    flag = false;
    setTimeout(() => {
      fn.apply(this, arguments);
      flag = true;
    }, wait);
  };
}

// by zy
function myThrottle(fn, delay) {
    let timer = null;
    return function (...args) {
        if (timer) return false;
        timer = setTimeout(() => {
            fn.call(this,...args);
            timer = null;
        },delay)
    }
}
```
